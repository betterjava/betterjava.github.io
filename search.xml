<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sharding-jdbc:原理与实现(一):主流程]]></title>
    <url>%2F2019%2F08%2F19%2Fshardingjdbc-mainprocess%2F</url>
    <content type="text"><![CDATA[使用方法(代码方式)123456789101112131415161718192021222324252627282930313233343536private static void testBasicUse() &#123; Map&lt;String, DataSource&gt; datasourceMap = new HashMap&lt;&gt;(); Properties pros = new Properties(); // 创建真正的dataSouce datasourceMap.put(&quot;cookie&quot;, getDbcpDatasource()); // 创建 分表规则 ShardingRuleConfiguration shardingRuleConfig = new ShardingRuleConfiguration(); TableRuleConfiguration tableRuleConfiguration = new TableRuleConfiguration(&quot;user&quot;, &quot;cookie.user_$-&gt;&#123;0..9&#125;&quot;); shardingRuleConfig.getTableRuleConfigs().add(tableRuleConfiguration); InlineShardingStrategyConfiguration inlineShardingStrategyConfiguration = new InlineShardingStrategyConfiguration(&quot;ex_id&quot;, &quot;user_$-&gt;&#123;ex_id % 10&#125;&quot;); shardingRuleConfig.setDefaultTableShardingStrategyConfig(inlineShardingStrategyConfiguration); try &#123; // 通过 ShardingDataSourceFactory 创建 ShardingDatasource DataSource dataSource = ShardingDataSourceFactory.createDataSource(datasourceMap, shardingRuleConfig, pros); // 通过 ShardingDatasource 创建 ShardingConnection Connection connection = dataSource.getConnection(); // 通过 ShardingConnection 创建 ShardingStatement Statement statement = connection.createStatement(); // 执行 并返回结果，这一步完成了 创建真实Connection 变 创建 真正Statement 并执行的结果 ResultSet rs = statement.executeQuery(&quot;select * from user&quot;); while (rs.next()) &#123; StringBuffer sb = new StringBuffer(); sb.append(rs.getLong(&quot;id&quot;)); sb.append(&quot;,&quot;); sb.append(rs.getString(&quot;name&quot;)); sb.append(&quot;,&quot;); sb.append(rs.getLong(&quot;ex_id&quot;)); System.out.println(sb.toString()); &#125; rs.close(); statement.close(); connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 主流程说明上面的代码中，DataSource,Connection和Statement 都是shardingjdbc包装后的对象，在生成这些对象的时候，并不创建真正的Connection和Statement。主要的解析、路由、执行、归并等都在 1ResultSet rs = statement.executeQuery(&quot;select * from user&quot;) 中进行 ShardingStatement1234567891011121314151617181920@Overridepublic ResultSet executeQuery(final String sql) throws SQLException &#123; ResultSet result; try &#123; clearPrevious(); // 路由 shard(sql); // 初始化执行器 initStatementExecutor(); // 执行sql，创建归并引擎示例 MergeEngine mergeEngine = MergeEngineFactory.newInstance(connection.getRuntimeContext().getDatabaseType(), connection.getRuntimeContext().getRule(), sqlRouteResult, connection.getRuntimeContext().getMetaData().getTable(), statementExecutor.executeQuery()); // 结果归并 result = getResultSet(mergeEngine); &#125; finally &#123; currentResultSet = null; &#125; currentResultSet = result; return result;&#125; shard(sql) 对sql进行解析、路由、和改写，将结果存放在 SQLRouteResult 中 initStatementExecutor() 根据路由结果，创建真正的Connection和Statement，放在 StatementExecutor 中 statementExecutor.executeQuery() StatementExecutor执行真正的Statement，并将所有结果返回到 List 中 result = getResultSet(mergeEngine) 将List进行归并，返回给客户端]]></content>
      <tags>
        <tag>shardingsphere</tag>
        <tag>sharding-jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to use Hexo]]></title>
    <url>%2F2019%2F08%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
