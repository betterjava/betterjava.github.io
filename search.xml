<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sharding-jdbc:原理与实现(三):线程池]]></title>
    <url>%2F2019%2F08%2F20%2Fshardingjdbc-threadpool%2F</url>
    <content type="text"><![CDATA[默认线程池大小sharding-jdbc 线程池，默认Executors.newCachedThreadPool()，可以通过以下参数进行配置 1EXECUTOR_SIZE(&quot;executor.size&quot;, String.valueOf(0), int.class), ShardingExecuteGroup1234public final class ShardingExecuteGroup&lt;T&gt; &#123; // sql 的集合，一个ShardingExecuteGroup 内部的 所有sql，都在同一个数据源上执行 private final List&lt;T&gt; inputs;&#125; ShardingExecuteGroup 是线程池执行任务的最小单位，原始sql都会被拆分成 几个ShardingExecuteGroup，每个ShardingExecuteGroup 内的sql 是串行执行的，并且对应 后端同一个数据源 1+n 并行模式如果原始sql被拆成4个ShardingExecuteGroup，则其中一个ShardingExecuteGroup 会在当前线程中执行，其余的3个会扔到线程中去执行。为什么不把所有的ShardingExecuteGroup 扔到线程池中去执行呢？我的理解是，针对OLTP的应用，绝大部分的查询最终只会路由到一个节点上执行一次sql，所以，这时候在当前线程中执行可以减少线程上下文切换 事务中执行如果当前ShardingConnection位于本地事务或者XA事务中，则所有的ShardingExecuteGroup的都会串行执行，为什么不能并行执行，这一点我没有理解，有些博客给了答案，但是仍然没有想清楚：博客 它的解释如下： 1）并行效率高，整个事务的耗时更少； 2）而串行在prepare阶段失败的情况下，只需部分回滚； 最末参与者优化”（Last Participant Optimization），术语来自支付宝]]></content>
      <categories>
        <category>shardingsphere</category>
      </categories>
      <tags>
        <tag>shardingsphere</tag>
        <tag>sharding-jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sharding-jdbc:原理与实现(二):事务]]></title>
    <url>%2F2019%2F08%2F19%2Fshardingjdbc-transaction%2F</url>
    <content type="text"><![CDATA[使用方法(代码方式)123456789101112131415161718192021222324Connection connection = null;try &#123; // 开启本地事务，TransactionType.XA xa 事务，TransactionType.BASE base 事务 TransactionTypeHolder.set(TransactionType.LOCAL); // 通过 ShardingDataSourceFactory 创建 ShardingDatasource DataSource dataSource = ShardingDataSourceFactory.createDataSource(datasourceMap, shardingRuleConfig, pros); // 通过 ShardingDatasource 创建 ShardingConnection connection = dataSource.getConnection(); connection.setAutoCommit(false); // 通过 ShardingConnection 创建 ShardingStatement Statement statement = connection.createStatement(); // 执行 并返回结果，这一步完成了 创建真实Connection 变 创建 真正Statement 并执行的结果 statement.executeUpdate(&quot;update user set name = &apos;cc&apos; where ex_id = 3&quot;); connection.commit(); statement.close(); connection.close();&#125; catch (SQLException e) &#123; try &#123; connection.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace();&#125; 本地事务 每个ShardingConnection都会缓存使用过的真实Connection 在connection.setAutoCommit(false)的时候，会把这条命令在所有缓存的的真实连接上执行 如果需要新创建Connection，则也会在这些连接上执行setAutoCommit(false)。但是这一步不是通过显式调用而是通过反射来进行的 1234567891011// 在 执行setAutommit(false)的时候，会把操作通过下面的方法缓存起来public final void recordMethodInvocation(final Class&lt;?&gt; targetClass, final String methodName, final Class&lt;?&gt;[] argumentTypes, final Object[] arguments) &#123; jdbcMethodInvocations.add(new JdbcMethodInvocation(targetClass.getMethod(methodName, argumentTypes), arguments));&#125; // 创建新连接后，会在新连接上通过反射调用 setAutommiit(false)public final void replayMethodsInvocation(final Object target) &#123; for (JdbcMethodInvocation each : jdbcMethodInvocations) &#123; each.invoke(target); &#125;&#125; commit或者rollback的时候，也会在所有缓存的真实Connecition上执行 分布式事务 dataSource.getConnection() 如果当前事务是分布式事务，则通过serverload 来加载真正的分布式事务实现 分布式事务都是委托给 ShardingTransactionManager 来完成 在connection.setAutoCommit(false)的时候，会在所有缓存的真实连接上执行 setAutoCommit(true)，并执行 ShardingTransactionManager.begin() commit和rollback也委托给ShardingTransactionManager 来执行 ShardingTransactionManager 将操作委托给真正的事务管理框架来完成，比如 Atomikos 12345678910111213141516171819public interface ShardingTransactionManager extends AutoCloseable &#123; // 将数据源包装成XADatasource void init(DatabaseType databaseType, Collection&lt;ResourceDataSource&gt; resourceDataSources); // 获取 事务类型 TransactionType getTransactionType(); boolean isInTransaction(); // 获取连接 Connection getConnection(String dataSourceName) throws SQLException; void begin(); void commit(); void rollback();&#125;]]></content>
      <categories>
        <category>shardingsphere</category>
      </categories>
      <tags>
        <tag>shardingsphere</tag>
        <tag>sharding-jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sharding-jdbc:原理与实现(一):主流程]]></title>
    <url>%2F2019%2F08%2F19%2Fshardingjdbc-mainprocess%2F</url>
    <content type="text"><![CDATA[使用方法(代码方式)123456789101112131415161718192021222324252627282930313233343536private static void testBasicUse() &#123; Map&lt;String, DataSource&gt; datasourceMap = new HashMap&lt;&gt;(); Properties pros = new Properties(); // 创建真正的dataSouce datasourceMap.put(&quot;cookie&quot;, getDbcpDatasource()); // 创建 分表规则 ShardingRuleConfiguration shardingRuleConfig = new ShardingRuleConfiguration(); TableRuleConfiguration tableRuleConfiguration = new TableRuleConfiguration(&quot;user&quot;, &quot;cookie.user_$-&gt;&#123;0..9&#125;&quot;); shardingRuleConfig.getTableRuleConfigs().add(tableRuleConfiguration); InlineShardingStrategyConfiguration inlineShardingStrategyConfiguration = new InlineShardingStrategyConfiguration(&quot;ex_id&quot;, &quot;user_$-&gt;&#123;ex_id % 10&#125;&quot;); shardingRuleConfig.setDefaultTableShardingStrategyConfig(inlineShardingStrategyConfiguration); try &#123; // 通过 ShardingDataSourceFactory 创建 ShardingDatasource DataSource dataSource = ShardingDataSourceFactory.createDataSource(datasourceMap, shardingRuleConfig, pros); // 通过 ShardingDatasource 创建 ShardingConnection Connection connection = dataSource.getConnection(); // 通过 ShardingConnection 创建 ShardingStatement Statement statement = connection.createStatement(); // 执行 并返回结果，这一步完成了 创建真实Connection 变 创建 真正Statement 并执行的结果 ResultSet rs = statement.executeQuery(&quot;select * from user&quot;); while (rs.next()) &#123; StringBuffer sb = new StringBuffer(); sb.append(rs.getLong(&quot;id&quot;)); sb.append(&quot;,&quot;); sb.append(rs.getString(&quot;name&quot;)); sb.append(&quot;,&quot;); sb.append(rs.getLong(&quot;ex_id&quot;)); System.out.println(sb.toString()); &#125; rs.close(); statement.close(); connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 主流程说明上面的代码中，DataSource,Connection和Statement 都是sharding-jdbc包装后的对象，在生成这些对象的时候，并不创建真正的Connection和Statement。主要的解析、路由、执行、归并等都在 1ResultSet rs = statement.executeQuery(&quot;select * from user&quot;) 中进行 ShardingStatement1234567891011121314151617181920@Overridepublic ResultSet executeQuery(final String sql) throws SQLException &#123; ResultSet result; try &#123; clearPrevious(); // 路由 shard(sql); // 初始化执行器 initStatementExecutor(); // 执行sql，创建归并引擎实例 MergeEngine mergeEngine = MergeEngineFactory.newInstance(connection.getRuntimeContext().getDatabaseType(), connection.getRuntimeContext().getRule(), sqlRouteResult, connection.getRuntimeContext().getMetaData().getTable(), statementExecutor.executeQuery()); // 结果归并 result = getResultSet(mergeEngine); &#125; finally &#123; currentResultSet = null; &#125; currentResultSet = result; return result;&#125; shard(sql) 对sql进行解析、路由、和改写，将结果存放在 SQLRouteResult 中 initStatementExecutor() 根据路由结果，创建真正的Connection和Statement，放在 StatementExecutor 中 statementExecutor.executeQuery() StatementExecutor执行真正的Statement，并将所有结果返回到 List 中 result = getResultSet(mergeEngine) 将List进行归并，返回给客户端]]></content>
      <categories>
        <category>shardingsphere</category>
      </categories>
      <tags>
        <tag>shardingsphere</tag>
        <tag>sharding-jdbc</tag>
      </tags>
  </entry>
</search>
